package jp.example;

import static java.util.stream.Collectors.*;
import static javax.servlet.DispatcherType.*;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;

import javax.servlet.FilterChain;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;

import org.apache.commons.lang3.exception.ExceptionUtils;

import jp.co.future.uroborosql.SqlAgent;
import jp.co.future.uroborosql.UroboroSQL;
import jp.co.future.uroborosql.config.SqlConfig;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

/**
 * Servlet JSP 向けの単一レイヤーアーキテクチャーコントローラーです。
 * <ul>
 * <li>単一レイヤー: Spring のような複数レイヤーでの開発や処理の分散が不要な Servlet 用です。
 * <li>トランザクション考慮不要: DB コネクションの取得・解放やロールバックは、uroboroSQL でこのクラスが行います。
 * <li>入力チェックは何でもいいので例外スローするだけ: とりあえず valid メソッドなどで例外スローすれば、message 属性にセットされます。
 * <li>自動フラッシュ属性: sendRedirect 時はリクエスト属性がリダイレクト先に自動的に引き継がれます。
 * <li>自動 CSRF チェック: JSP や各サーブレットでは考慮不要です。
 * </ul>
 * @author Generated by Pleiades All in One New Gradle Project Wizard (EPL)
 */
@WebFilter("/*")
@Slf4j
public class SingleTierController extends HttpFilter {
	
	/**
	 * @return カレントスレッドの DAO インスタンス
	 * <pre>
	 * 自動採番の主キーを持つテーブは、id などのエンティティに関するアノテーションは不要です。
	 * スネークケース、キャメルケースは自動変換されます。ただし、バインドパラメータ名は変換されません。
	 * <a href="https://future-architect.github.io/uroborosql-doc/background/"
	 * >GitHub: uroboroSQL - 2WaySQL</a>
	 * </pre>
	 */
	public static SqlAgent dao() {
		return daoThreadLocal.get();
	}
	
	/**
	 * 入力チェックなどの正当性をチェックし、不正な場合は指定したメッセージを持つ例外をスローします。
	 * @param isValid 正しい場合は true
	 * @param message 上記が false の時に例外がスローされ、リクエスト属性に "message" としてセットされます。
	 * @param args メッセージの %s や %d に String#format で埋め込む文字列
	 */
	public static void valid(boolean isValid, String message, Object... args) {
		if (!isValid) {
			throw new IllegalStateException(String.format(message, args));
		}
	}
	
	//-------------------------------------------------------------------------
	
	/** カレントスレッドのトランザクション境界内で DAO インスタンスを保持 */
	private static final ThreadLocal<SqlAgent> daoThreadLocal = new ThreadLocal<>();
	
	/** DAO 接続設定 */
	private SqlConfig daoConfig;

	/** サーブレット呼び出し前後のフィルター処理 */
	@Override @SneakyThrows
	protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) {
		req.setCharacterEncoding(StandardCharsets.UTF_8.name());
		
		// リダイレクト呼び出し時に、リクエスト属性をフラッシュ属性として保存
		HttpSession session = req.getSession();
		res = new HttpServletResponseWrapper(res) {
			@Override
			public void sendRedirect(String location) throws IOException {
				session.setAttribute("flashMap", 
					Collections.list(req.getAttributeNames()).stream().collect(toMap(e -> e, req::getAttribute)));
				String s = location.replaceFirst("[\\?&]$", "");
				super.sendRedirect(s + (s.contains("?") ? "&" : "?") + "_redirected"); // 復元識別パラメーター追加
			}
		};
		
		// リダイレクト後のリクエストで、フラッシュ属性をリクエスト属性として復元
		@SuppressWarnings("unchecked")
		Map<String, Object> flashMap = (Map<String, Object>) session.getAttribute("flashMap");
		if (flashMap != null) {
			if (req.getParameter("_redirected") != null) {
				flashMap.forEach(req::setAttribute);
			}
			session.removeAttribute("flashMap");
		}
		
		// POST で CSRF エラーの場合はトップ画面にリダイレクト
		final String CSRF_NAME = "_csrf";
		String sesCsrf = (String) session.getAttribute(CSRF_NAME);
		String reqCsrf = Arrays.stream(req.getCookies()).filter(e -> e.getName().equals(CSRF_NAME))
				.map(Cookie::getValue).findFirst().orElse(null);
		
		String newCsrf = UUID.randomUUID().toString();
		session.setAttribute(CSRF_NAME, newCsrf);
		res.addHeader("Set-Cookie", String.format("%s=%s; %sHttpOnly; SameSite=Strict",
				CSRF_NAME, newCsrf, req.isSecure() ? "Secure; " : ""));
		
		if ("POST".equals(req.getMethod()) && reqCsrf != null && !reqCsrf.equals(sesCsrf)) {
			req.setAttribute("message", "二重送信または不正なリクエストを無視しました。");
			res.sendRedirect(".");
			return;
		}
		
		// DB トランザクションの開始、コミット、ロールバック
		try (SqlAgent dao = daoConfig.agent()) {
			try {
				daoThreadLocal.set(dao);
				super.doFilter(req, res, chain);
			}
			// サーブレットで発生したすべての例外に対して以下の処理を行う
			// 1. データベーストランザクションのロールバック
			// 2. ルート例外メッセージをリクエスト属性 "message" にセット
			// 3. 呼び出し元画面 (最後にフォワードされた JSP) にフォワード
			catch (Exception e) {
				dao.rollback();
				Throwable cause = ExceptionUtils.getRootCause(e);
				if (!(cause instanceof IllegalStateException)) {
					log.error(e.getMessage(), e);
				}
				req.setAttribute("message", cause.getMessage());
				req.getRequestDispatcher((String) session.getAttribute("jspPath")).forward(req, res);
			}
		}
	}

	/** サーブレットフィルター初期化時のデータベース接続情報と初期データの設定 */
	@Override @SneakyThrows
	public void init() {
		Class.forName("org.h2.Driver");
		daoConfig = UroboroSQL.builder("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "").build();
		try (SqlAgent dao = daoConfig.agent()) {
			dao.updateWith("""
					CREATE TABLE item (
						id INT AUTO_INCREMENT, name VARCHAR(100), release_date CHAR(10), face_auth BOOLEAN,
						PRIMARY KEY (id)
					);
					INSERT INTO item (name, release_date, face_auth) VALUES 
						('iPhone 13 Pro Docomo版','2022-09-11',true),
						('iPhone 13 Pro Max Docomo版','2022-12-05',true),
						('Xperia 1 IV 国内版','2022-07-22',false)
					;
				""").count();
		}
	}

	/** 最後にフォーワードした JSP を保存するフィルター */
	@WebFilter(urlPatterns = "*.jsp", dispatcherTypes = FORWARD)
	public static class ForwardJspPathSaveFilter extends HttpFilter {
		
		@Override @SneakyThrows
		protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) {
			req.getSession().setAttribute("jspPath", req.getServletPath());
			super.doFilter(req, res, chain);
		}
	}
}
